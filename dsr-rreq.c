#include <linux/proc_fs.h>
#include <linux/timer.h>
#include <net/ip.h>

#include "debug.h"
#include "dsr.h"
#include "tbl.h"
#include "kdsr.h"
#include "dsr-rrep.h"
#include "dsr-rreq.h"
#include "dsr-opt.h"
#include "dsr-rtc.h"
#include "dsr-dev.h"
#include "send-buf.h"

#define RREQ_TBL_MAX_LEN 64 /* Should be enough */
#define RREQ_TBL_PROC_NAME "dsr_rreq_tbl"
#define RREQ_TTL_MAX 8
#define RREQ_TLB_MAX_ID 16

static TBL(rreq_tbl, RREQ_TBL_MAX_LEN);

struct rreq_tbl_entry {
	struct list_head l;
	struct in_addr addr;
	struct timer_list timer;
	struct rreq_id {
		struct in_addr trg;
		unsigned long id;
	} rreq_ids[RREQ_TLB_MAX_ID];
	int id_ndx;   /* Index into rreqs_recvd array */
	int ttl;
	int rreqs;
	unsigned long time;
	unsigned long expire;
};

struct rreq_tbl_query {
	struct in_addr addr;
	struct in_addr trg;
	unsigned long id;
};


static unsigned int rreq_seqno = 1;

static void rreq_tbl_resend_timeout(unsigned long data);
int dsr_rreq_send(struct in_addr target, int ttl, unsigned long timeout);

static inline int crit_addr(void *pos, void *addr)
{
	struct in_addr *a = addr; 
	struct rreq_tbl_entry *p = pos;
	
	if (p->addr.s_addr == a->s_addr)
		return 1;

	return 0;
}

static inline int crit_addr_del(void *pos, void *addr)
{
	struct in_addr *a = addr; 
	struct rreq_tbl_entry *p = pos;
	
	if (p->addr.s_addr == a->s_addr) {
		if (timer_pending(&p->timer))
			del_timer(&p->timer);
		return 1;
	}
	return 0;
}

static inline int crit_expire(void *pos, void *expire)
{
	unsigned long *exp = expire; 
	struct rreq_tbl_entry *p = pos;
	
	if (p->expire == *exp)
		return 1;

	return 0;
}

static inline int crit_time(void *pos, void *new)
{
	struct rreq_tbl_entry *n = new;
	struct rreq_tbl_entry *p = pos;
	
	if (p->time > n->time)
		return 1;

	return 0;
}

static inline int crit_pending(void *pos, void *target)
{
	struct in_addr *trg = target;
	struct rreq_tbl_entry *p = pos;
	
	if (p->addr.s_addr == trg->s_addr && timer_pending(&p->timer))
		return 1;

	return 0;
}
static inline int crit_query(void *pos, void *query)
{
	struct rreq_tbl_query *q = query;
	struct rreq_tbl_entry *p = pos;
	
	if (p->addr.s_addr == q->addr.s_addr) {
		int i = 0;

		for (i = 0; i < RREQ_TLB_MAX_ID; i++)
			if (p->rreq_ids[i].trg.s_addr == q->trg.s_addr &&
			    p->rreq_ids[i].id == q->id)
				return 1;
	}
	return 0;
}

static inline int timer_remove(void *entry, void *data)
{
	struct rreq_tbl_entry *e = entry;

	if (timer_pending(&e->timer)) {
		del_timer(&e->timer);
		return 1;
	}
	return 0;
}


static void rreq_tbl_set_timer(struct rreq_tbl_entry *e)
{
	read_lock_bh(&rreq_tbl.lock);
	e->timer.function = rreq_tbl_resend_timeout;
	e->timer.expires = e->timer.data = e->expire;
	add_timer(&e->timer);
	read_unlock_bh(&rreq_tbl.lock);
}

static void rreq_tbl_resend_timeout(unsigned long data)
{
	struct rreq_tbl_entry *e;
	int ttl, rreqs;
	struct in_addr trg;
	
	DEBUG("RREQ TBL resend timeout!\n");
	
	read_lock_bh(&rreq_tbl.lock);
	/* Find the first RREQ entry that this node originated */
	e = __tbl_find(&rreq_tbl, &data, crit_expire);
	
	ttl = e->ttl + 2;
	trg = e->addr;
	rreqs =  ++e->rreqs;
	read_unlock_bh(&rreq_tbl.lock);

	if (ttl < RREQ_TTL_MAX)
		dsr_rreq_send(trg, ttl, 80 * (ttl + 2) * 2);
	
}

int rreq_tbl_add(struct in_addr addr, struct in_addr src, struct in_addr trg, 
		 int ttl, unsigned int id, unsigned long timeout)
{
	struct rreq_tbl_entry *e;
	struct in_addr myaddr;
	int set_timer = 0;
	unsigned long time = jiffies;
	
	myaddr = my_addr();
	
	e = tbl_find_detach(&rreq_tbl, &addr, crit_addr);
	
	/* If this add event was generated by a new RREQ, but a RREQ is already
	 * pending --> do not change anything */
	if (e && src.s_addr == myaddr.s_addr && timer_pending(&e->timer)) {
		tbl_add(&rreq_tbl, &e->l, crit_time);
		return 0;
	}
	       
	if (!e) {
		e = kmalloc(sizeof(struct rreq_tbl_entry), GFP_ATOMIC);

		if (!e)
			return -1;
		
		memset(e, 0 , sizeof(struct rreq_tbl_entry));
		init_timer(&e->timer);

		e->id_ndx = 0;
		e->rreqs = 0;

		write_lock_bh(&rreq_tbl.lock);

		/* Remove first (least recently used) entry */
		if (rreq_tbl.len >= rreq_tbl.max_len) {
			struct rreq_tbl_entry *f;
			f = (struct rreq_tbl_entry *)TBL_FIRST(&rreq_tbl);
			
			__tbl_detach(&rreq_tbl, &f->l);
			
			if (timer_pending(&f->timer))
				del_timer(&f->timer);
			
			kfree(f);
		}
		write_unlock_bh(&rreq_tbl.lock);
	}
	
	e->addr = addr;
	e->time = time;
	e->ttl = ttl;

	if (src.s_addr == myaddr.s_addr) {
		e->expire = time + (timeout * HZ / 1000);
		DEBUG("Resend timeout in %lu ms\n", (e->expire - time) * 1000 /
HZ);
		
		set_timer = 1;
	} else {
		e->rreq_ids[e->id_ndx].trg = trg;
		e->rreq_ids[e->id_ndx].id = id;
		e->id_ndx = ++e->id_ndx % RREQ_TLB_MAX_ID;
	}

	/* Add it at the correct place */
	tbl_add(&rreq_tbl, &e->l, crit_time);
	
	if (set_timer)
		rreq_tbl_set_timer(e);
	
	return 1;
}

int rreq_tbl_del(struct in_addr dst)
{
	return tbl_for_each_del(&rreq_tbl, &dst, crit_addr_del);
}


static struct dsr_rreq_opt *dsr_rreq_opt_add(char *buf, int len, 
					struct in_addr target)
{
	struct dsr_rreq_opt *rreq_opt;

	if (!buf || len < DSR_RREQ_HDR_LEN)
		return NULL;

	rreq_opt = (struct dsr_rreq_opt *)buf;
	
	rreq_opt->type = DSR_OPT_RREQ;
	rreq_opt->length = 6;
	rreq_opt->id = htons(rreq_seqno++);
	rreq_opt->target = target.s_addr;
	
	return rreq_opt;
}

static inline int dsr_rreq_pending(struct in_addr target)
{
	return in_tbl(&rreq_tbl, &target, crit_pending);
}
static inline int dsr_rreq_duplicate(struct in_addr src, struct in_addr trg, unsigned long id)
{
	struct rreq_tbl_query q;

	q.addr = src;
	q.trg = trg;
	q.id = id;
	
	return in_tbl(&rreq_tbl, &q, crit_query);
}

int dsr_rreq_send(struct in_addr target, int ttl, unsigned long timeout)
{
	struct dsr_pkt *dp;
	char *buf;
	int len = IP_HDR_LEN +DSR_OPT_HDR_LEN + DSR_RREQ_HDR_LEN;
	
	if (dsr_rreq_pending(target)) {
		DEBUG("RREQ recently sent for %s\n", print_ip(target.s_addr));
		return 0;
	}

	dp = dsr_pkt_alloc(NULL, len);

	if (!dp) {
		DEBUG("Could not allocate DSR packet\n");
		return -1;
	}

	dp->data = NULL; /* No data in this packet */
	dp->data_len = 0;
	dp->dst.s_addr = DSR_BROADCAST;
	dp->nxt_hop.s_addr = DSR_BROADCAST;
	dp->dsr_opts_len = len;
	dp->src = my_addr();
	
	buf = dp->dsr_data;
	
	dp->nh.iph = dsr_build_ip(buf, IP_HDR_LEN, IP_HDR_LEN + len, 
				  dp->src, dp->dst, ttl);
	
	if (!dp->nh.iph) 
		goto out_err;

	buf += IP_HDR_LEN;
	len -= IP_HDR_LEN;

	dp->dh.opth = dsr_opt_hdr_add(buf, len, 0);
	
	if (!dp->dh.opth) {
		DEBUG("Could not create DSR opt header\n");
		goto out_err;
	}
	
	buf += DSR_OPT_HDR_LEN;
	len -= DSR_OPT_HDR_LEN;
	
	dp->rreq_opt = dsr_rreq_opt_add(buf, len, target);

	if (!dp->rreq_opt) {
		DEBUG("Could not create RREQ opt\n");
		goto out_err;
	}
	
	dp->nh.iph->ttl = ttl;
	
	DEBUG("Sending RREQ for %s ttl=%d\n", print_ip(target.s_addr), ttl);

	rreq_tbl_add(target, dp->src, target, ttl, rreq_seqno, timeout);
	
	dsr_dev_xmit(dp);

	return 0;

 out_err:	
	dsr_pkt_free(dp);

	return -1;
}
int dsr_rreq_route_discovery(struct in_addr target)
{
        int ttl = 1;

        return dsr_rreq_send(target, ttl, 80 * (ttl + 2));
}

int dsr_rreq_opt_recv(struct dsr_pkt *dp)
{
	struct in_addr myaddr;
	struct in_addr trg;
	struct dsr_srt *srt_rev;

	if (!dp || !dp->rreq_opt)
		return DSR_PKT_DROP;

	myaddr = my_addr();
	
	if (dp->src.s_addr == myaddr.s_addr)
		return DSR_PKT_DROP;
	
	trg.s_addr = dp->rreq_opt->target;

	if (dsr_rreq_duplicate(dp->src, trg, dp->rreq_opt->id)) {
		DEBUG("Duplicate RREQ from %s\n", print_ip(dp->src.s_addr));
		return DSR_PKT_DROP;
	}
	rreq_tbl_add(dp->src, dp->src, trg, dp->nh.iph->ttl, dp->rreq_opt->id, 0);

	dp->srt = dsr_srt_new(dp->src, myaddr,
			      DSR_RREQ_ADDRS_LEN(dp->rreq_opt),
			      (char *)dp->rreq_opt->addrs);
	
	if (!dp->srt) {
		DEBUG("Could not extract source route\n");
		return DSR_PKT_ERROR;
	}
	DEBUG("RREQ target=%s\n", print_ip(dp->rreq_opt->target));
	DEBUG("my addr %s\n", print_ip(myaddr.s_addr));
	
        /* Add reversed source route */
	srt_rev = dsr_srt_new_rev(dp->srt);
	
	if (!srt_rev) {
		DEBUG("Could not reverse source route\n");
		return DSR_PKT_ERROR;
	}
	DEBUG("srt: %s\n", print_srt(dp->srt));

	DEBUG("srt_rev: %s\n", print_srt(srt_rev));
	
	dsr_rtc_add(srt_rev, 60000, 0);
	
	/* Send buffered packets */
	send_buf_set_verdict(SEND_BUF_SEND, srt_rev->dst.s_addr);

	kfree(srt_rev);
		
	if (dp->rreq_opt->target == myaddr.s_addr) {

		DEBUG("RREQ OPT for me\n");
		
		/* According to the draft, the dest addr in the IP header must
		 * be updated with the target address */
		dp->nh.iph->daddr = dp->rreq_opt->target;
	
		
		return DSR_PKT_SEND_RREP;
	} else {
		int i, n;
		/* TODO: Reply if I have a route */
		
		n = DSR_RREQ_ADDRS_LEN(dp->rreq_opt) / sizeof(struct in_addr);
		
		/* Examine source route if this node already exists in it */
		for (i = 0; i < n; i++)
			if (dp->srt->addrs[i].s_addr == myaddr.s_addr)
				return DSR_PKT_DROP;
		
	      
		/* Forward RREQ */
		return DSR_PKT_FORWARD_RREQ;
	}

	return DSR_PKT_DROP;
}
static int rreq_tbl_print(char *buf)
{
	struct list_head *pos;
	int len = 0;
    
	read_lock_bh(&rreq_tbl.lock);
    
	len += sprintf(buf, "# %-15s %-6s Time      entries=%d max_entries=%d\n", "Addr", "TTL",  rreq_tbl.len, rreq_tbl.max_len);

	list_for_each(pos, &rreq_tbl.head) {
		struct rreq_tbl_entry *e = (struct rreq_tbl_entry *)pos;
		
		len += sprintf(buf+len, "  %-15s %-6u %lu\n", 
			       print_ip(e->addr.s_addr), e->ttl,
			       e->time ? ((jiffies - e->time) * HZ) : 0);
	}
    
	read_unlock_bh(&rreq_tbl.lock);
	return len;

}


static int rreq_tbl_proc_info(char *buffer, char **start, off_t offset, int length)
{
	int len;

	len = rreq_tbl_print(buffer);
    
	*start = buffer + offset;
	len -= offset;
	if (len > length)
		len = length;
	else if (len < 0)
		len = 0;
	return len;    
}

int __init rreq_tbl_init(void)
{
	proc_net_create(RREQ_TBL_PROC_NAME, 0, rreq_tbl_proc_info);
	return 0;
}

void __exit rreq_tbl_cleanup(void)
{
	tbl_flush(&rreq_tbl, timer_remove);
	proc_net_remove(RREQ_TBL_PROC_NAME);
}

